\chapter*{Kurzfassung}

Diese Arbeit pr√§sentiert zwei Methoden zur Komprimierung von formalen Beweisen.
Formale Beweise sind von gro{\ss}er Bedeutung in der modernen Informatik.
Sie k\"onnen verwendet werden um deduktive Systeme miteinander zu kombinieren. 
Ein Beispiel sind SAT Solver \cite{Biere2009}, welche ob ihrer Effektivit\"at gerne f\"ur diverse Berechnungen verwendet werden.
Ein formaler Beweis kann als Zertifikat f\"ur die Korrektheit des Ergebnisses eines SAT Solvers dienen.
Des Weiteren k\"onnen aus ihnen Informationen, wie etwa Interpolanten \cite{McMill2005} oder Unerf\"ullbarkeitskerne, extrahiert werden, welche zur L\"osung eines Problems beitragen \cite{Hofferek2013}.

Formale Beweise sind typischerweise sehr gro{\ss}, siehe etwa \cite{Konev2014} f\"ur einen 13 GB Beweis eines Falles der Erd\H{o}s Discrepancy Conjecture.
Bei solchen Beweisgr\"o{\ss}en sto{\ss}en Computersysteme an ihre Grenzen und deswegen ist es erforderlich Beweise zu komprimieren.
Unsere Arbeit pr\"asentiert zwei Methoden zur Beweiskomprimierung.

Die erste Methode entfernt Redundanzen im Kongruenzteil von SMT Beweisen.
Kongruenzbeweise schlie{\ss}en von einer Menge an Gleichungen auf neue Gleichungen mit der Voraussetzung der vier Axiome: \emph{Reflexivit\"at}, \emph{Symmetrie}, \emph{Transitivit\"at} und \emph{Kompatibilit\"at}.
Beweise, die von SMT Solvern erzeugt werden, schlie{\ss}en oft auf neue Gleichungen aus einer unn\"otig gro{\ss}en Menge.
Wir pr\"asentieren einen neuen Kongruenzschluss- Algorithmus, der Erkl\"arungen f\"ur gew\"unschte Gleichungen produziert und zeigen, dass diese Erkl\"arungen k\"urzer sind als solche in Benchmark- Beweisen.
Diese k\"urzeren Erkl\"arungen \"ubersetzen sich \"ublicherweise in k\"urzere Teilbeweise und einen komprimierten Gesamtbeweis.
Des Weiteren beweisen wir, dass das Problem des Findens der k\"urzesten Erkl\"arung NP-Vollst\"andig ist.

Die zweite Methode untersucht die Speicherplatzanforderungen von Beweisen.
Beim Bearbeiten von Beweisen muss nicht der gesamte Beweis zu jeder Zeit im Speicher gelagert sein.
Teilbeweise werden erst in den Speicher geladen, wenn sie ben\"otigt werden und werden wieder aus diesem entfernt, sobald sie nicht mehr ben\"otigt werden.
In welcher Reihenfolge die Teilbeweise geladen werden, ist essentiell f\"ur die maximale Speicherplatzanforderung.
Wir wollen Reihenfolgen mit niedrigen Speicherplatzanforderungen mit Hilfe von zwei neuen Algorithmen und einer Reihe an Heuristiken konstruieren.