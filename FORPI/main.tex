\documentclass{llncs}
\usepackage{etex}

\usepackage{xcolor}
\usepackage{enumitem,amsmath,amssymb}
\usepackage{breakurl}    % used for \url and \burl
\usepackage[linesnumbered,boxed,noline,noend]{algorithm2e}
\def\defaultHypSeparation{\hskip.1in}

\usepackage{tikz}
\usepackage{subfig}
\usepackage{array,booktabs,multirow}
\usepackage{placeins}

\usepackage{logictools}
\usepackage{prooftheory}
\usepackage{comment}
\usepackage{mathenvironments}
\usepackage{drawproof}
\usepackage{bussproofs}
\usepackage{tensor}
\usepackage{mathtools}
\usepackage{amsmath}

\usepackage{graphicx}
%\usepackage{caption}
%\usepackage{subcaption}

\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\renewcommand{\floatpagefraction}{0.75}


\newcommand{\freevar}[1]{\mathrm{FV}(#1)}

\newcommand{\Vertices}[1]{V_{#1}}
\newcommand{\Edges}[1]{E_{#1}}
\newcommand{\Conclusion}[1]{\clause_{#1}}

\newcommand{\axiom}[1]{\widehat{#1}}
\newcommand{\n}{v}
\newcommand{\raiz}[1]{\rho(#1)}

\newcommand{\pedge}[3]{\ensuremath{\raiz{#1} \xrightarrow{#2} \raiz{#3}}}


\newcommand\inlineeqno{\stepcounter{equation}\ (\theequation)}


% Contraction
\newcommand{\con}[3]{\lfloor #1 \rfloor_{#2}^{#3}}

% Resolution
%\newcommand{\res}[6]{#1 \tensor[^{#2}_{#3}]{\odot}{^{#4}_{#5}} #6}
%\newcommand{\res}[6]{#1 \prescript{#2}{#3}{\odot^{#4}_{#5}} #6}

\newcommand{\res}[4]{\mathrel{\operatorname*{\odot}_{#1 #3}^{#2 #4}}}

\title{Compression of First-Order Resolution Proofs by Partial Regularization} %Working title only

\author{
  Jan Gorzny\inst{1}
  \thanks{Supported by the Google Summer of Code 2014 program.}
  \and 
  Bruno Woltzenlogel Paleo\inst{2}
  \thanks{Supported by the Austrian Science Fund, project P24300.}
}

\authorrunning{J.\~Gorzny \and B.\~Woltzenlogel Paleo}

\institute{
  \email{jgorzny@uvic.ca}, University of Victoria, Canada
  \and 
  \email{bruno@logic.at}, Vienna University of Technology, Austria
}




\begin{document}

\maketitle


\begin{abstract}%TODO: this
This paper describes a generalization of the recently developed \RecyclePivotsIntersection algorithm applicable to first-order logic proofs generated by automated theorem provers. \RecyclePivotsIntersection removes inferences with a node $\eta$ when its pivot literal occurs as the pivot of another inference located below in the path from $\eta$ to the root of the proof. The algorithm is then combined with \SFOLowerUnits in order to compress first-order proofs further. A preliminary empirical evaluation of the combination of these compression algorithms is presented.
\end{abstract}


\setcounter{footnote}{0}

\section{Introduction}
%TODO: re-write 
%Most of the effort in automated reasoning so far has been dedicated to the design and implementation of proof systems and efficient theorem proving procedures. As a result, saturation-based first-order automated theorem provers have achieved a high degree of maturity, with resolution and superposition being among the most common underlying proof calculi. Proof production is an essential feature of modern state-of-the-art provers and proofs are crucial for applications where the user requires certification of the answer provided by the prover. Nevertheless, efficient proof production is non-trivial,
%non-trivial \cite{SchultzAPPA}, 
%and it is to be expected that the best, most efficient, provers do not necessarily generate the best, least redundant, proofs. Therefore, it is a timely moment to develop methods that post-process and simplify proofs. %While the foundational problem of simplicity of proofs can be traced back at least to Hilbert's 24th Problem, the maturity of automated deduction has made it particularly relevant today.  

Fist-order automated theorem provers have recent achieved a high degree of maturity, commonly using the resolution and superposition proof calculi. Although proof production is a key feature of such provers and proofs are crucial for applications where the prover is required to certify its answer, proof production is non-trivial. The best, most efficient provers do not necessarily generate the best, least redundant proofs.

%For proofs generated by SAT- and SMT-solvers, which use propositional resolution as the basis for the DPLL and CDCL decision procedures, there is now a wide variety of proof compression techniques. Algebraic properties of the resolution operation that might be useful for compression were investigated in \cite{bwp10}.
For proofs using propositional resolution generated by SAT- and SMT-solvers, there is a wide variety of proof compression techniques. Algebraic properties of the resolution operation that might be useful for compression were investigated in \cite{bwp10}.
Compression algorithms based on rearranging and sharing chains of resolution inferences have been
developed in \cite{Amjad07} and \cite{Sinz}.  Cotton \cite{CottonSplit} proposed an algorithm that
compresses a refutation by repeatedly splitting it into a proof of a heuristically chosen literal $\ell$
and a proof of $\dual{\ell}$, and then resolving them to form a new refutation.  The {\ReduceReconstruct} algorithm \cite{RedRec} searches for locally redundant
subproofs that can be rewritten into subproofs of stronger clauses and with fewer resolution steps.
A linear time proof compression algorithm based on partial
regularization was proposed in \cite{RP08} and improved in \cite{LURPI}. %Furthermore, \cite{LURPI} also described a new linear time algorithm called {\LowerUnits}, which delays resolution with unit clauses.

%In contrast, for first-order theorem provers, there has been up to now (to the best of our knowledge) no attempt to design and implement an algorithm capable of taking a first-order resolution DAG-proof and efficiently simplifying it, outputting a possibly shorter pure first-order resolution DAG-proof. 

There has been less work on simplifying first-order proofs. There are algorithms aimed at simplifying first-order sequent calculus tree-like proofs, based on cut-introduction \cite{BrunoLPAR,Hetzl}. There is also an algorithm \cite{LPARCzech} that looks for terms that occur often in any TSTP \cite{TPTP} proof (including first-order resolution DAG-proofs) and introduces abbreviations for these terms. However, as the definitions of the abbreviations are not part of the output proof, it cannot be checked by a pure first-order resolution proof checker.

Recently, it has been shown that propositional proof compression algorithms can be lifted to compress first-order proofs. In \cite{}, it was shown that {\LowerUnits} could be lifted in this manner to produce {\SFOLowerUnits} ({\GFOLU}) with positive results. We continue this process by lifting the \RecyclePivotsIntersection ({\RPI}) algorithm described in \cite{}. {\RPI} is a modification of the \texttt{RecyclePivots} ({\RP}) algorithm \cite{Bar-IlanFuhrmannHooryShachamStrichman2009Linear-time-reductions-of-resolution-proofs}, which  provides better compression on proofs where nodes have several children.

%TODO: edit this again
Section \ref{sec:res} introduces the first-order resolution calculus and notation used. Section \ref{sec:Challenges} shows the challenges that arise from unification during resolution which are not present the propositional case. Section \ref{sec:FORPI} describes modifications necessary to overcome these challenges. Section \ref{sec:exp} concludes the paper by presenting preliminary experimental results obtained by applying this algorithm along with {\GFOLU} on hundreds of proofs generated with the {\SPASS} theorem prover. 
%SPASS} theorem prover \cite{SPASS}. 
%The next section introduces the first-order resolution calculus using notations that are more convenient for describing proof transformation operations.






\input{sec-Resolution}
%\input{sec-PropositionalLU}
\input{sec-Challenges}
%\input{sec-FOLU}
%\input{sec-SimpleFOLU}
\input{sec-FORPI}
\input{sec-Exp}



%\section{Conclusions and Future Work}
%TODO: this section?
%{\FORPI} continues to support the idea of listing propositional proof compression algorithms to the first-order case. The experimental results discussed in the previous continue to be encouraging, and are consistent with trends observed in the propositional case. 

%\paragraph{Acknowledgments:}


\begin{footnotesize}
%\bibliographystyle{splncs}
\bibliographystyle{plain}
\bibliography{biblio}
\end{footnotesize}

\end{document}

% vim: tw=100
