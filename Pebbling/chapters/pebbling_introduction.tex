\section{Introduction}

SAT- and SMT-solvers are among the most efficient tools for the verification and synthesis of software \cite{Biere2009,Hofferek2013}. 
%\marginpar{ToDo: find more citations here. Handbook of satisfiability} 
However, proofs generated by SAT- and SMT-solvers can be huge. 
Checking their correctness or extracting information (e.g. unsatisfiable cores, interpolants) from them can not only take a long time but also consume a lot of memory. 
In an ongoing project for interpolant-based controller synthesis \cite{Hofferek2013}, 
for example, extracting an interpolant from an SMT-proof took hours and reached the limit of memory (256GB) available in a single node of the computer cluster used in the project. This issue is also relevant in application scenarios in which the proof consumer, who is interested in independently processing proofs, might have less available memory than the proof producer.

Typically, proof formats do not allow proof producers to inform the proof consumer when proof nodes (containing clauses) could be released from memory. Consequently, every proof node loaded into memory has to be kept there until the whole proof is completely processed, because the proof consumer does not know whether the proof node will still be needed. To address this issue, recently proposed proof formats for SAT-proofs such as DRAT and BDRUP enrich the older RUP proof format with node deletion instructions \cite{raey}. Other proof formats, such as the TraceCheck format \cite{BiereHeuleAPPA} or formats for SMT-proofs \cite{BarrettFontaineMouraAPPA}, could also be enriched analogously. When generating a proof file eagerly (i.e. writing learned clauses immediately to the proof file) a SAT- or SMT-solver can add a deletion instruction for every clause that is deleted by the periodic clean-up of its database of derived learned clauses.

This paper explores the possibility of post-processing a proof in order to increase the amount of deletion instructions in the proof file. The more deletion instructions, the less memory the proof consumer will need. 

%Therefore, this \emph{deletion-during-proof-postprocessing} approach ought to be seen not as a replacement but rather as an independent complement to the \emph{deletion-during-proof-search} already performed by state-of-the-art proof-generating SAT-solvers.

The new methods proposed here exploit an analogy between proof checking and playing \emph{Pebbling Games} \cite{Kasai1979,Gilbert1980}.
In Section \ref{sec:resolution} we define propositional resolution proofs and make the notion of processing a proof formal.
The particular version of pebbling game relevant for proof processing is defined precisely in Section \ref{sec:pebbling-game}, where we also explain the analogy to proof processing in detail and define the space measure of proofs. The proposed pebbling algorithms are greedy (Section \ref{sec:algorithms}) and based on heuristics (Section \ref{sec:heuristics}). As discussed in Sections \ref{sec:pebbling-game} and \ref{sec:pebblingSAT}, approaches based on exhaustive enumeration or on encoding as a SAT problem would not fare well in practice.

The proof space compression algorithms described here are not restricted to proofs generated by SAT- and SMT-solvers. They are general DAG pebbling algorithms, that could be applied to proofs represented in any calculus where proofs are directed acyclic graphs (including the special case of tree-like proofs) \cite{APPA}. It is nevertheless in SAT and SMT that proofs tend to be largest and in most need of space compression. The underlying propositional resolution calculus satisfies the DAG requirement. The experiments (Section \ref{sec:experiments}) evaluate the proposed algorithms on thousands of SAT- and SMT-proofs.


