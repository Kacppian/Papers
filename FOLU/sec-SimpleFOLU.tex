
\section{A Simpler First-Order LowerUnits}
\label{sec:SimpleFOLU}

ToDo by Jan

%\input{FOSubExample.tex}

A simple way to decrease the complexity to linear with respect to the length of the proof is to return to the ideas used in the propositional case. In particular, by performing a traversal to collect the units of a proof, and then optimistically deleting units, some compression can often be achieved. By ignoring whether or not a unit satisfies Property \ref{prop:rootpair}, we can attempt to lower it, and should compression fail because the resulting proof was too different than the original (i.e. the deletions changed the substitutions to the point where contraction was not possible), we simply return the original proof. 

\begin{algorithm}[bt]
  \SetAlgoVlined
  \SetAlgoShortEnd
\SetKwFunction{check}{check}
  \KwIn {a proof $\psi$}
  \KwOut{a compressed proof $\psi^{\star}$}
  \KwData{a map $.'$: after line 4, it maps any $\varphi$ to \Del{$\varphi$, $D$}}
  \KwData{a map $\dl{.}$,mapping literals to changed literals,updated after every deletion}
  \BlankLine

  \SetKwData{Units}{Units}

  \SetKw{Remove} {remove}
  \SetKw{Break} {break}

  \algolines{\Units $\leftarrow \varnothing$}{queue to store collected units and literals resolved away by each unit}
  \BlankLine

  \For{every subproof $\varphi$, in a bottom-up traversal of $\psi$}{
    \lIf{$\varphi$ is a unit with more than one child}{enqueue $(\varphi, \ell_\varphi)$ in \Units, where $\ell_\varphi$ is the set of literals resolved away by $\varphi$}
  }
  \BlankLine

\check{\Units} %don't include? we check 'on-the-fly'

\BlankLine

    $\psi' \leftarrow $ \FuncSty{simple-fo-delete}$(\psi,\Units)$ \;
    \BlankLine

    \tcp{Reintroduce units}
    

    $\psi^{\star} \leftarrow \psi'$ \;
    \For{every unit $\varphi$ in \Units}{
      \Let{$\{\ell\} = \Conclusion{\varphi}$} \;
      \Let{$\{ \ell_1, \ldots, \ell_n \}$ be the literals resolved against $\ell$ in $\psi$ } \;
      \Let{$c = \{ \dl{\ell_1},\ldots,\dl{\ell_n} \} \backslash \{ \none \}$} \;
      \If{$c$'s literals are not unifiable}{
        \Return{$\psi$}
      }
      \ElseIf{$c \neq \emptyset$}{
        \Let{$\sigma$ be the unifier of $c$'s literals and $\ell^c$ the unified literal} \;
        $\psi^{\star} \leftarrow \con{\psi^{\star}}{c}{\sigma} \res{\ell^c}{}{\dl{\ell}}{} \varphi'$ \;
      }
    }
  
    

  \caption{\SFOLowerUnits}
  \label{algo:simpleFOLU}
\end{algorithm}

Algorithm \ref{algo:simpleFOLU} thus works similarly to the propositional algorithm.  It first performs a bottom up traversal to collect potential units and the literals that are resolved away from by those units, adding the units to a queue (line 1). As seen in Examples \ref{ex:pairwise} in Section \ref{sec:Challenges}, unification of the resolved away literals is necessary, so it performs a check to make sure these literals satisfy Property \ref{prop:pair} (line 4). If it succeeds, it attempts to re-introduce all the removed units at the bottom of the proof, where it attempts to compress the literals that would be resolved away by each unit (lines 6-15). Note that this requires the implementation to track which literals should be resolved against each unit. In order to avoid traversing the proof to find these again after the deletion of every potential unit (as is done in Algorithm \ref{algo:FOLU}), we use a modify \FuncSty{fo-delete} function, called \FuncSty{simple-fo-delete}, shown in Algorithm \ref{algo:sfodel}.

\FuncSty{simple-fo-delete} is designed to reduce the complexity of tracking literals. \FuncSty{simple-fo-delete} behaves much more closely to the propositional case and requires none of the additional data structures required by \FuncSty{fo-delete}. In this function, when a unit node is returned, instead of returning the opposite node (respectively $\psi_L'$ or $\psi_R'$, line 6) in the resolution (which is done in the propositional case), or tracking the literals (which is done in \FuncSty{fo-delete}), we return the opposite node with $\sigma_L$ (respectively $\sigma_R$) applied to it. In this way, the literals not resolved with the unit will look like they would have in the original proof, and the literal which was not resolved due to the deletion looks like it is syntactically equal with the unit literal at this stage. A negative side-effect of this is that we may end up grounding literals, and having to carry these forms of each literal forward, which may increase the character length of the clause, though not the number of nodes in the proof.

However, that by modifying delete in this manner, we can longer guarantee that Property \ref{prop:rootpair} is satisfied. This property was simply never checked. In particular, this may change the appearance of literals that were to be resolved away from a unit clause, preventing completion of the proof. Thus if a unit fails to satisfy Property \ref{prop:rootpair} postponing resolution, {\SFOLowerUnits} may attempt to re-introduce this node and fail. In these cases, \SFOLowerUnits will return the original input proof (line 12). As a result, some proofs that can be compressed are returned unmodified, but those that do not require this additional property can be compressed much more quickly.



\begin{algorithm}[bt]
  \SetAlgoVlined
  \SetAlgoShortEnd
  \KwIn{a proof $\varphi$}
  \KwIn{$D$ a set of subproofs}
  \KwOut{a proof $\varphi'$ obtained by deleting the subproofs in $D$ from $\varphi$}
  \BlankLine

  \newcommand{\fixL}{\ensuremath{\varphi'_L}}
  \newcommand{\fixR}{\ensuremath{\varphi'_R}}

  \lIf{$\varphi \in D$ or $\raiz{\varphi}$ has no premises}{\Return{$\varphi$}}
  \BlankLine

  \Else{$\varphi = \varphi_L \res{\ell_L}{\sigma_L}{\ell_R}{\sigma_R} \varphi_R$\;
    $\varphi'_L \leftarrow $ \Rec{$\varphi_L$,$D$} \;
    $\varphi'_R \leftarrow $ \Rec{$\varphi_R$,$D$} \;
    \BlankLine

    \lIf{$\varphi'_L \in D$}{ 
      \Return{$($\fixR $\sigma_R)$} 
    }
    \lElseIf{$\varphi'_R \in D$}{ 
      \Return{$($\fixL $\sigma_R)$}  
    }
    \BlankLine


    \lElse{ 
      \Return{ \fixL~$\res{\dl{\ell_L}}{}{\dl{\ell_R}}{}$~\fixR}
    }
  }



  \caption[.]{\FuncSty{simple-fo-delete}}
  \label{algo:sfodel}
\end{algorithm}