\section{Introduction}

Proofs have the potential to play an important role in ensuring trust
between independent software tools that transfer knowledge, solutions
and computation results among each other, because proofs can serve as
certificates of correctness of what is communicated. This potential is
already being realized in the field of automated reasoning, where
proof exchange for theorem proving
\cite{PxTP2013,PxTP2015} is routinely used to
enable verified cooperation among a vast variety of proof-producing
automated deduction tools \cite{APPA}, as exemplified in systems such
as Sledgehammer \cite{paulson2010three} and
HOLyHammer\cite{zbMATH06419295}. 

SAT- and SMT- Solvers are widely used as subroutines to solve problems in various domains.
Clearly solvers are not immune to bugs \cite{brummayer2009fuzzing,brummayer2010automated} that may lead to wrong results.
Fortunately, there is a simple way to certify the output of such solvers and 
prevent the potentially dangerous propagation of an error in them.

In case of the positive result ``satisfiable formula'', the certificate is a model of the formula.
Checking a model for spuriousness can be done by substituting the variables of the formula with the respective values in the model and 
calculating the truth value of the resulting variable free formula.

In case of the negative result ``unsatisfiable formula'', the certificate is a proof of unsatisfiability.
Checking a proof for spuriousness, can be done by replaying the proof and validating the correct application of every proof rule.
Typically this is a much more expensive task than checking whether a model is spurious.
%Typically, a proof is much larger than a model and thereby checking the proof is a much more expensive task than checking the correctness of a model.
Nevertheless, to encourage certification of unsatisfiability, the yearly SAT competition\footnote{\url{http://baldur.iti.kit.edu/sat-competition-2016/}} has introduced a Certified UNSAT track in 2013.

%\marginpar{ToDo: throughout the paper, the QED (box) symbol is often appearing after a line break, in the left side. It should appear in the right side without a line break.}
An example of application where certified correctness is crucial is the verification and synthesis of software \cite{Biere2009,Hofferek2013}. 
%SAT- and SMT-solvers are among the most efficient tools for this task, but the proofs they generate can be huge. 
%Checking their correctness or extracting information (e.g. unsatisfiable cores, interpolants) from them can not only take a long time but also consume a lot of memory. 
In an ongoing project for interpolant-based controller synthesis \cite{Hofferek2013}, 
for example, extracting an interpolant from an SMT-proof took hours and reached the limit of memory (256GB) available in a single node of the computer cluster used in the project. 
The example shows one serious issue with proofs: they tend to be huge, easily filling up all available memory, and therefore hard to process independently.
%This issue is relevant in any application scenario in which proof consumers, who are interested in independently processing proofs, might have less available memory than the proof producer.

Typically, proof formats do not allow proof producers to inform the proof consumer when proof nodes (containing clauses) could be released from memory. Consequently, every proof node loaded into memory has to be kept there until the whole proof is completely processed, because the proof consumer does not know whether the proof node will still be needed. To address this issue, recently proposed formats for SAT-proofs such as DRAT and BDRUP enrich the older RUP format with node deletion instructions \cite{raey}. Other proof formats, such as the TraceCheck format \cite{BiereHeuleAPPA} or formats for SMT-proofs \cite{BarrettFontaineMouraAPPA}, could also be enriched analogously. When generating a proof file eagerly (i.e. writing learned clauses immediately to the proof file) a SAT- or SMT-solver can add a deletion instruction for every clause that is deleted by the periodic clean-up of its database of derived learned clauses.

This paper explores the possibility of post processing a proof in order to increase the amount of deletion instructions in the proof file. 
The more deletion instructions, the less memory the proof consumer will need.

%Therefore, this \emph{deletion-during-proof-postprocessing} approach ought to be seen not as a replacement but rather as an independent complement to the \emph{deletion-during-proof-search} already performed by state-of-the-art proof-generating SAT-solvers.

The new methods proposed here exploit an analogy between proof checking and playing \emph{Pebbling Games} \cite{Kasai1979,Gilbert1980}.
In Section \ref{sec:resolution} we define propositional resolution proofs and make the notion of processing a proof formal.
The particular version of pebbling game relevant for proof processing is defined precisely in Section \ref{sec:pebbling-game}, where we also explain the analogy to proof processing in detail and define the space measure of proofs. The proposed pebbling algorithms are greedy (Section \ref{sec:algorithms}) and based on heuristics (Section \ref{sec:heuristics}). As discussed in Sections \ref{sec:pebbling-game} and \ref{sec:pebblingSAT}, approaches based on exhaustive enumeration or on encoding as a SAT problem would not fare well in practice.

The proof space compression algorithms described here are not restricted to proofs generated by SAT- and SMT-solvers. They are general DAG pebbling algorithms, that could be applied to proofs represented in any calculus where proofs are directed acyclic graphs (including the special case of tree-like proofs) \cite{APPA}. It is nevertheless in SAT and SMT that proofs tend to be largest and in most need of space compression. The underlying propositional resolution calculus satisfies the DAG requirement. The experiments (Section \ref{sec:experiments}) evaluate the proposed algorithms on thousands of SAT- and SMT-proofs.

\subsection{Related Work}

Techniques for compressing proofs in size have been conceived for proofs in the propositional logic resolution calculus \cite{cotton2010two,DBLP:conf/sat/Gupta12,DBLP:conf/tableaux/BoudouP13,DBLP:conf/hvc/BloemMSW14}, the first order resolution calculus \cite{DBLP:conf/cade/GorznyP15}, as well as in the first order sequent calculus \cite{BrunoLPAR,Hetzl}.
To the best of our knowledge, no technique to deliberately compress the space of proofs in any calculus has been conceived yet.

The trade-off in size, width and space between different proofs of the same formula is investigated in \cite{Ben-Sasson2002}.
However, no constructive method is provided to obtain a proof with low space requirements.
Furthermore, the focus of our work in different, since we consider traversal orders of a fixed proof instead of constructing a completely new proof.
The motivation for this approach is that proof compression should ultimately deliver proofs with low size and low space requirements at the same time.
%we do not want to sacrifice space reduction for size increase.

New proof formats, such as DRAT \cite{raey}, help in lowering space requirements during proof processing, by explicitly highlighting at which point proof nodes can be deleted from memory.
We aim to construct proof traversal orders that have these deletion points as beneficial as possible for peek memory consumption.

%\texttt{Skeptik} (\url{https://github.com/Paradoxika/Skeptik}) \cite{Boudou2014} is a proof compression tool working on both propositional- and first order logic.
%\texttt{GAPT} (\url{http://www.logic.at/gapt/}) \cite{GAPT} is a proof theory framework that is able to perform proof compression in the form of cut-elemination and cut-introduction.
%\texttt{MINLOG} (\url{http://www.mathematik.uni-muenchen.de/\textasciitilde logik/minlog/}), which extracts functional programs from proofs, employing a refined A-translation.