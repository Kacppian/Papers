
\section{A Simpler First-Order LowerUnits}
\label{sec:SimpleFOLU}

%\input{FOSubExample.tex}

A simple way to decrease the complexity to linear with respect to the length of the proof is to return to the ideas used in the propositional case. In particular, by performing a traversal to collect the units of a proof, and then optimistically deleting units, some compression can often be achieved. By ignoring whether or not a unit satisfies Property \ref{prop:rootpair}, we can attempt to lower it, and should compression fail because deletions changed the substitutions to the point where contraction was not possible, we simply return the original proof. 

\begin{algorithm}[bt]
  \SetAlgoVlined
  \SetAlgoShortEnd
\SetKwFunction{check}{check}
  \KwIn {a proof $\psi$}
  \KwOut{a compressed proof $\psi^{\star}$}
  \KwData{a map $.'$: after line 4, it maps any $\varphi$ to \Del{$\varphi$, $D$}}
  \BlankLine

  \SetKwData{Units}{Units}

  \SetKw{Remove} {remove}
  \SetKw{Break} {break}

  \algolines{\Units $\leftarrow \varnothing$}{queue to store collected units}
  \BlankLine

  \For{every subproof $\varphi$, in a bottom-up traversal of $\psi$}{
    \lIf{$\varphi$ is a unit with more than one child and all literals of $\varphi$ are simultaneously unifiable}{enqueue $\varphi$ in \Units}
  }
  \BlankLine

    $\psi' \leftarrow $ \FuncSty{simple-fo-delete}$(\psi,\Units)$ \;
    \BlankLine

    \tcp{Reintroduce units}
    

    $\psi^{\star} \leftarrow \psi'$ \;
    \For{every unit $\varphi$ in \Units}{
        \Let{$\sigma$ be the unifier of $\rho(\psi^\star)$'s literals that contracts $\rho(\psi^\star)$ as much as possible} \;
        \Let{$c$ be the literals contracted by $\sigma$} \;
       \If{$ \con{\psi^{\star}}{c}{\sigma}$ and $\varphi'$ can be resolved} {
        $\psi^{\star} \leftarrow \con{\psi^{\star}}{c}{\sigma} \res{\ell^c}{}{\ell}{} \varphi'$ \;
        }\Else { \Return $\psi$}
      
    }
  
    

  \caption{\SFOLowerUnits}
  \label{algo:simpleFOLU}
\end{algorithm}

Algorithm \ref{algo:simpleFOLU} works similarly to the propositional algorithm.  It first performs a bottom up traversal to collect potential units and the literals that are resolved away from by those units, adding the units to a queue (line 1). As seen in Examples \ref{ex:pairwise} in Section \ref{sec:Challenges}, unification of the resolved away literals is necessary, so it performs a check to make sure these literals satisfy Property \ref{prop:pair} (line 4). If it succeeds, it attempts to re-introduce all the removed units at the bottom of the proof, where it attempts to compress the literals that would be resolved away by each unit (lines 6-15). Note that this requires the implementation to track which literals should be resolved against each unit. In order to avoid traversing the proof to find these again after the deletion of every potential unit (as is done in Algorithm \ref{algo:FOLU}), we use a modified \FuncSty{delete} function, called \FuncSty{simple-fo-delete}, which is the same as Algorithm \ref{algo:del} except with line 6 changed to the following:

   \lIf{$~\varphi'_L \in D~$}{ 
     \Return{$(\rho(\varphi'_L) \sigma_R)$} 
    }
    \lElseIf{$\varphi'_R \in D$}{ 
      \Return{$(\rho(\varphi'_R) \sigma_R)$}  
    }

\FuncSty{simple-fo-delete} is designed to reduce the complexity of tracking literals. \FuncSty{simple-fo-delete} behaves much more closely to the propositional case and requires none of the additional data structures required by \FuncSty{fo-delete}. In this function, when a unit node is returned, instead of returning the opposite node (respectively $\psi_L'$ or $\psi_R'$, line 6) in the resolution (which is done in the propositional case), or tracking the literals (which is done in \FuncSty{fo-delete}), we return the opposite node with $\sigma_L$ (respectively $\sigma_R$) applied to it. In this way, the literals not resolved with the unit will look like they would have in the original proof, and the literal which was not resolved due to the deletion looks like it is syntactically equal with the unit literal at this stage. The fact that the other literals look like they did in the original proof is key: now resolution in the compressed proof can use the old literals, which should appear as they before, and not worry about choosing the wrong literal in case of ambiguous resolution.

%A negative side-effect of this is that we may end up grounding literals, and having to carry these forms of each literal forward, which may increase the character length of the clause, though not the number of nodes in the proof.

Additionally, by modifying delete in this manner we can longer guarantee that Property \ref{prop:rootpair} is satisfied. Property \ref{prop:rootpair} so the appearance of literals that were to be resolved away from a unit clause may have changed, preventing completion of the proof. If this happens {\SFOLowerUnits} will attempt to re-introduce this node and fail, returning the original input proof (line 12). As a result, some proofs that can be compressed are returned unmodified, but those that do not require this additional property can be compressed much more quickly.



%\input{simple-fo-delete-full}


