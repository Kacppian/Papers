


\section{First-Order Challenges}\label{sec:Challenges}

TODO by Jan (just writing some ideas so far--not yet final by any means)\\
{\bf Does this belong here?And is this what you had in mind for interesting examples? And are the proof formatted correctly, or should I change them? aside from the first one going over the margin right now of course}\\ 

In this section, we discuss additional requirements for lowering a unit formula in the first order case that are not required in the propositional case.

%example 1: shows requirement for pair-wise unifiability with unit
 \begin{example} The following example shows why we want to check formula unifiability with the unit we're trying to lower.

\begin{tiny}
\begin{prooftree}
\def\e{\mbox{\ $\vdash$\ }}
\AxiomC{$p(Y)$\e$q(Z)$}
\AxiomC{\e$p(Y)$}
\BinaryInfC{\e$q(Z)$}
\AxiomC{$p(X),q(Z)$\e}
\BinaryInfC{$p(X)$\e}
\AxiomC{\e$p(Y)$}
\BinaryInfC{$\bot$}
\end{prooftree}
\end{tiny}

which we could compress to
\begin{tiny}
\begin{prooftree}
\def\e{\mbox{\ $\vdash$\ }}
\AxiomC{$p(Y)$\e$q(Z)$}
\AxiomC{$p(X),q(Z)$\e}
\BinaryInfC{$p(X),p(Y)$\e}
\UnaryInfC{$p(X)$\e}
\AxiomC{\e$p(Y)$}
\BinaryInfC{$\bot$}
\end{prooftree}
\end{tiny}
 \end{example}


%example 2: shows requirement for pair-wise unifiability within all aux formulas

 \begin{example} The following example shows why we must check pair-wise unifiability with the literals resolved against the unit we're trying to lower.

\begin{tiny}
\begin{prooftree}
\def\e{\mbox{\ $\vdash$\ }}
\AxiomC{$\eta_2$}
\AxiomC{$\eta_1$: $p(a)$\e$q(Y),r(Z)$}
\AxiomC{$\eta_2$: \e $p(X)$}
\BinaryInfC{$\eta_3$: \e$q(Y),r(Z)$}
\AxiomC{$\eta_4$: $r(X),p(b)$\e $s(Y)$}
\BinaryInfC{$\eta_5$: $p(b)$\e $s(Y),q(Y)$}
\AxiomC{$\eta_6$: $s(Y), q(Y)$\e}
\BinaryInfC{$\eta_7$: $p(b)$\e}
\BinaryInfC{$\psi$: $\bot$}
\end{prooftree}
\end{tiny}
 \end{example}


%example 3: shows requirement for contraction check

 \begin{example} The following shows why the above is not necessarily  enough (we must check the original sources of the aux formulas, and see if those can be contracted), otherwise we might not save anything.
\begin{footnotesize}
\begin{prooftree}
\def\e{\mbox{\ $\vdash$\ }}
\AxiomC{$\eta_1$: $r(Y),p(X ~q(Y~b)), p(X~Y)$\e}
\AxiomC{$\eta_2$: \e $p(U~V)$}
\BinaryInfC{$\eta_3$: $r(V),p(U ~q(V~b))$\e}
\AxiomC{$\eta_4$: \e $r(W)$}
\BinaryInfC{$\eta_5$: $p(U ~q(W~b))$\e}
\AxiomC{$\eta_2$}
\BinaryInfC{$\psi$: $\bot$}
\end{prooftree}
\end{footnotesize}
 \end{example}


%example 4: requires FOSubstitution, introduces this concept
\begin{example}\label{ex:ambig} Consider the following, which shows the dangers of ambiguous resolution in the first order case:\\
\begin{tiny}
\begin{prooftree}
\def\e{\mbox{\ $\vdash$\ }}
\AxiomC{$p(U),r(U~V),r(V~U),q(V)$\e}
\AxiomC{\e$p(c)$}
\BinaryInfC{$r(c~V),r(V~c),q(V)$\e}
\AxiomC{\e$r(X~c)$}
\BinaryInfC{$r(c~X),q(X)$\e}
\AxiomC{\e$r(W~V)$}
\BinaryInfC{$q(V)$\e}
\AxiomC{$p(Z)$\e$q(d)$}
\BinaryInfC{$p(Z)$\e}
\AxiomC{\e$p(c)$}
\BinaryInfC{$\bot$}
\end{prooftree}
\end{tiny}

Which if we lower $\vdash p(c)$, we would attempt to resolve  the following two sequents
$$p(U),r(U~V),r(V~U),q(V)\vdash$$
$$\vdash r(X~c)$$
Where we would have to be careful. If we used $r(U~V)$, then we would use the unifier $U->X, V->C$, which would result in the following:
$$p(X),r(V~X),q(c)\vdash$$
but the original proof does not have a method for resolving away $q(c)$, so we would not be able to complete the proof. On the other hand, if we chose $r(V~U)$, we would unify with $V->X, U->c$, with which we could complete the proof:

\begin{footnotesize}
\begin{prooftree}
\def\e{\mbox{\ $\vdash$\ }}
\AxiomC{$p(U),r(U~V),r(V~U),q(V)$\e}
\AxiomC{\e$r(X~c)$}
\BinaryInfC{$p(c),r(c~X),q(X)$\e}
\AxiomC{\e$r(W~V)$}
\BinaryInfC{$p(c),q(V)$\e}
\AxiomC{$p(Z)$\e$q(d)$}
\BinaryInfC{$p(c),p(Z)$\e}
\UnaryInfC{$p(c)$\e}
\AxiomC{\e$p(c)$}
\BinaryInfC{$\bot$}
\end{prooftree}
\end{footnotesize}

A method to avoid this issue is discussed in section \ref{sec:SimpleFOLU}
 \end{example}
