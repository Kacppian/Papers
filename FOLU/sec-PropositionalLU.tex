\section{The Propositional LowerUnits Algorithm}
\label{sec:PropositionalLU}

We denote by $\dn{\psi}{\varphi_1, \varphi_2}$ the result of deleting the subproofs $\varphi_1$ and $\varphi_2$ from the proof $\psi$ and fixing it according to Algorithm \ref{algo:del}\footnote{
  The deletion algorithm is a minor variant of the \textsc{Reconstruct-Proof} algorithm presented in \cite{RP11}.
  The basic idea is to traverse the proof in a top-down manner, replacing
  each subproof having one of its premises marked for deletion (i.e. in $D$) by its other direct subproof. For more details, we refer to \ref{Boudou}.
}. 
We say that a subproof $\varphi$ in a proof $\psi$ can be lowered 
if there exists a proof
$\psi'$ such that $\psi' = \dn{\psi}{\varphi} \odot \varphi$ and
$\Conclusion{\psi'} \subseteq \Conclusion{\psi}$. If $\varphi$ originally participated in many resolution inferences within $\psi$ (i.e. if $\varphi$ had many children in $\psi$) then lowering $\varphi$ compresses the proof (in number of resolution inferences), because $\dn{\psi}{\varphi} \odot \varphi$ contains a single resolution inference involving $\varphi$.

%
It has been noted in \cite{LURPI} that, in the propositional case, $\varphi$ can always be lowered if it is a \emph{unit} (i.e. its conclusion clause is unit). This led to the invention of {\LowerUnits} (Algorithm \ref{algo:LU}), which aims at transforming a proof $\psi$ into $(\dn{\psi}{\mu_1,\ldots,\mu_n}) \odot_{\ell_1} \mu_1 \odot \ldots \odot_{\ell_n} \mu_n$, where $(\mu_1,\ldots,\mu_n)$ are all units with more than one child. Units with only one child are ignored merely because no compression is gained by lowering them. The order in which the units are reintroduced is important:
if a unit $\varphi_2$ is a subproof of a unit
$\varphi_1$ then $\varphi_2$ has to be reintroduced later than (i.e. below) $\varphi_1$.



\SetKwFunction{Rec}{delete}
\SetKw{Let}{let}

\begin{algorithm}[bt]
  \KwIn{a proof $\varphi$}
  \KwIn{$D$ a set of subproofs}
  \KwOut{a proof $\varphi'$ obtained by deleting the subproofs in $D$ from $\varphi$}
  \BlankLine

  \newcommand{\fixL}{\ensuremath{\varphi'_L}}
  \newcommand{\fixR}{\ensuremath{\varphi'_R}}

  \lIf{$\varphi \in D$ or $\raiz{\varphi}$ has no premises}{\Return{$\varphi$}}
  \BlankLine

  \Else{
    \Let{$\varphi_L$ and $\varphi_R$} be such that
      $\varphi = \varphi_L \res{\ell_L}{\sigma_L}{\ell_R}{\sigma_R} \varphi_R$ \;
    \Let{$\varphi'_L = $ \Rec{$\varphi_L$,$D$}} \;
    \Let{$\varphi'_R = $ \Rec{$\varphi_R$,$D$}} \;
    \BlankLine

    \lIf{$\varphi'_L \in D$}{ \Return{\fixR} }
    \lElseIf{$\varphi'_R \in D$}{ \Return{\fixL} }
    \BlankLine

    \lElseIf{$\dual{\ell} \notin \Conclusion{\fixL}$}{ \Return{\fixL} }
    \lElseIf{$\ell \notin \Conclusion{\fixR}$}{ \Return{\fixR} }
    \BlankLine

    \lElse{ \Return{ \fixL~$\res{\ell_L}{\sigma_L}{\ell_R}{\sigma_R}$~\fixR} }
  }

  \caption[.]{\FuncSty{delete}}
  \label{algo:del}
\end{algorithm}





A possible presentation of {\LowerUnits} is shown in Algorithm \ref{algo:LU}. Units are collected
during a first traversal. As this traversal is bottom-up, units are stored in a queue. The traversal
could have been top-down and units stored in a stack. Units are effectively deleted during a second,
top-down traversal. The last for-loop performs the reintroduction of units.

\begin{algorithm}[bt]
  \KwIn {a proof $\psi$}
  \KwOut{a compressed proof $\psi'$}
  \BlankLine

  \SetKwData{Units}{Units}
  \Units $\leftarrow \varnothing$ \;
  \BlankLine

  \For{every subproof $\varphi$ in a bottom-up traversal}{
    \If{$\varphi$ is a unit and has more than one child}{Enqueue $\varphi$ in \Units \; }
  }
  \BlankLine

  $\psi' \leftarrow $ \Rec{$\psi$,$\Units$} \;
  \BlankLine

  \For{every unit $\varphi$ in \Units}{
    \Let{$\{\ell\} = \Conclusion{\varphi}$} \;
    \lIf{$\dual{\ell} \in \Conclusion{\psi'}$}{
    $\psi' \leftarrow \psi' \odot_\ell \varphi$}
  }

  \caption{\LowerUnits}
  \label{algo:LU}
\end{algorithm}
